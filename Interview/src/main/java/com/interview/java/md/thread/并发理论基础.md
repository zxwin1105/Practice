
## 一、CPU架构

现代CPU一般会采用多核模式，每个内核可以独立工作。多核CPU架构图如下：

![CPU架构图](../../../../../../resources/image/CPU架构.png)

 为了均衡内存与CPU之间的速度差异，CPU中设计了多级缓存L1,L2,L3。

### 1.1 CPU多级缓存

- L3缓存：L3缓存容量最大，速度最慢，是多个核心间共享的内存。

- L2缓存：L2缓存容量适中，速度较快，内核独享。

- L1缓存：L1缓存容量最小，速度最快，内核独享。L1缓存内部分为两部分，一部分存储指令单元，一部分存储数据单元。

CPU多级缓存速度大小：寄存器 > L1 > L2 > l3 > 内存

>知识点：缓存是由最小的存储区块--缓存行（cacheLine）组成，缓存行的大小通常为64byte。
> 
>eg: L1缓存大小为512kb，而cacheLine=64byte，则L1有512kb * 1024 / 64个cacheLine。

### 1.2 局部性原理

在CPU访问存储设备时，无论是存取数据还是存储指令，都趋于聚集在一片连续的区域内，被称为局部性原理。

- 时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期很可能还会被再次访问。

- 空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附件的位置也会被引用。

## 二、为什么需要多线程？

在计算机中，CPU、内存、IO设备的速度是有很大差异的，为了提高CPU的利用率，平衡3者的速度差异，计算机体系结构、操作系统
编译程序都做出了贡献，主要表现为：

- CPU增加了缓存，均衡与内存的速度差异，导致了可见性问题

- 操作系统增加了进程、线程用于分时复用CPU，均衡CPU与IO设备的差异，出现了原子性问题

- 编译程序优化了指令执行次序，使得缓存能够得到更加合理的利用，导致了有序性问题

### 2.1 并发三要素

1. 原子性

**原子性是指一个或多个操作，要么全部执行完成并且执行过程中不被任何因素打断，要么不执行。**

原子性引发的线程安全问题，在多线程的环境中，对共享变量做操作（操作由多个操作组成），可能会由于线程间的切换导致线程安全问题。
简单来说引发原子性问题的原因是由于CPU分时复用造成的。

案例：

```java
// 共享遍历
int i=1;

public void factor(){
    i+=1;
}
```
> 注意i+=1操作是分为三部完成的
> 
> 1. 获取i本身值
> 2. 将i与1相加
> 3. 将相加后的值赋给i

现有线程A和线程B，线程A首先执行方法factor()，当线程A执行完第2步，（此时i仍=1）；CPU切换到线程B开始执行方法factor()，知道线程B执行完factor()后，
CPU才切换到线程A（此时i=?）。

我们希望得到的正确结果是i=3，因为两个线程都执行的factor()方法，相当于i=1+1+1=3。但是如果发生上述情况，则i=2。当执行完线程B后i=2，CPU切换回
线程A，此时将继续执行线程A没有执行完的操作（开始执行第3步,此时i=3）将i+1赋值给i(i=2)，最终写入内存的数是i=2。

2. 可见性

**可见性是指一个线程对共享变量的操作，另一个线程能立即看到。**

可见性引发的线程安全问题，在现代CPU架构中会设计多级缓存，CPU会从缓存中获取数据，将数据写入缓存，可能就会造成缓存数据与内存数据不一致问题。

案例：

```java
//线程A执行的代码
int i = 0;
i = 10;
 
//线程B执行的代码
j = i;
```
假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。# 原子性: 分时复用引起

3. 有序性

**有序性是指程序的执行顺序是按照代码的先后顺序执行的**

在程序执行时，为了提高性能，编译器和处理器会对指令做重排序，重排序分为3中类型：

- 编译器优化的重排序，编译器在不改变单线程程序语义前提下，可以重新安排预计的执行顺序。

- 指令级并行的重排序，现代处理器采用了指令级并行计数，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

## 三、Java如何解决并发问题（Java内存模型）

### 3.1 并发编程模型的分类

在并发变成中，我们需要处理两个关键问题：线程间




## 参考

> 
>著作权归@pdai所有
>原文链接：https://pdai.tech/md/java/thread/java-thread-x-theorty.html
> 